프로그래머스에서 진행한 데브매칭에 참가했다. [[Link]](https://programmers.co.kr/competitions/144/2020-web-be-first)



어떤방식으로 풀었었는지 코딩테스트에 대한 후기를 남기고자 한다.

문제가 있다면 댓글,메일등으로 연락주시면 내리도록하겠다.





#### 1. 자물쇠

![자물쇠](https://blog.chanwookim.me/images/1523061554_oD91xVMg_ED156A71-1219-4982-8C23-1045A8E9AFBB.jpeg)

첫번째문제는 사진과 같은 비밀번호를 돌리는 자물쇠의 비밀번호를 알고있을때

몇번 이동해야 자물쇠를 열수있는가를 묻는 문제였다.

현재 111이면 222를 만들려면 각 자리마다 1칸씩 움직여 1+1+1 =  3을 출력하면 되는식이다.

주의할점은 9에서 앞으로 한칸을가면 0이고 0에서 뒤로한칸가면 9라는것 정도인것같다.

큐를 이용해서 풀면 되겠다 싶었다. 한자리씩 한쪽방향으로 계속 돌리면서 큐에 넣고 비밀번호와 일치하면 큐에서 꺼내서 몇칸 움직였는지 세는 방식으로 해결했다.



```python
def bfs(cur_num, target):
    result = []

    count = 0
    curr = cur_num
    q = [curr]
    while q:
        # print(q, curr, target, count)
        if curr != target:
            curr += 1
            if curr == 10:
                curr = 0
            q.append(curr)
            count += 1

        else:
            q.pop(0)
            result.append(count)
            break


    count = 0
    curr = cur_num
    q = [curr]
    while q:
        # print(q, cur_num, target, count)
        if cur_num != target:
            cur_num -= 1
            if cur_num == -1:
                cur_num = 9
            q.append(cur_num)
            count += 1

        else:
            q.pop(0)
            result.append(count)
            break


    return min(result)


def solution(p, s):
    all_count = 0
    for ep, es in zip(p, s):
        all_count += bfs(int(ep), int(es))

    return all_count


p, s = "82195", "64723"
# p, s = "0", "9"
print(solution(p, s))

```





#### 2. 로봇청소기



[go, left, right] 명령을 받아서 청소하는 로봇청소기를 구현해보는 문제

문제를 잘 보고 문제에 설명된대로 하나씩 만들었더니 해결할수있었다.

현재 로봇이 어느 방향을 보고있는지를 확인후 right, left 명령에 맞춰 방향을 설정하고

```
[1, 0]# 위로 한칸
[0, 1]# 오른쪽으로 한칸
[-1, 0]# 아래로 한칸
[0, -1]# 왼쪽으로 한칸

```

go 가 들어왔을때 현재 방향에 맞는곳으로 한칸 이동하면된다.

만약 전체 범위 밖의 공간이거나 장애물이 있다면 이동하지않고 그자리에 있는다.

```python
def solution(office, r, c, move):
    N = len(office)

    # for o in office:
    #     print(o)

    dir_go = [[-1, 0], [0, 1], [1, 0], [0, -1]]
    direction = 0


    ans = office[r][c]
    office[r][c] = 0

    for command in move:

        if command == "go":

            curr = office[r][c]

            next_r = r + dir_go[direction][0]
            next_c = c + dir_go[direction][1]

            if next_r < 0 or next_r >= N or next_c < 0 or next_c >= N:
                next_r = r
                next_c = c

            if office[next_r][next_c] != -1:
                r = next_r
                c = next_c

                ans += office[r][c]
                print(office[r][c])
                office[r][c] = 0

        if command == "right":
            direction = (direction + 1) % 4

        if command == "left":
            direction = (direction - 1) % 4

        print(command, direction, "(", r, ",", c, ")", ans)
    return ans


o, r, c, m = [[5, -1, 4], [6, 3, -1], [2, -1, 1]], 1, 0, ["go", "go", "right", "go", "right", "go", "left", "go"]

o, r, c, m = [[5, -1, 4], [6, 3, -1], [2, -1, 1]], 1, 0, ["go", "go", "go", "go", "go", "go", "go", "go"]
o, r, c, m = [[5, -1, 4], [6, 3, -1], [2, -1, 1]], 1, 0, ["left", "left", "go", "go", "go", "go", "go", "go"]

print(solution(o, r, c, m))

```







#### 3. 인접한 수의 차이 최소화

이 문제는 시간안에 해결하지 못하였다. 

입력된 수로 만들수있는 모든 순열을 만들어서 원래 입력된 값과 몇자리가 다른지 비교하면

몇번 swap됐는지 알수있지 않았을까..라는 생각이 든다.

다른 자리를 구해서 짝수면 2로 나누고 홀수면 2로나누고 1을 더해주었는데..이게 맞는방법일지

채점을 다시 돌려볼수없으니 확인할 방법을 모르겠다. 

```python
import itertools


def solution(numbers, K):
    N = len(numbers)
    candidate = []
    min_count = 1000


    perms = list(itertools.permutations(numbers))
    for p in perms:
        count = 0
        for i in range(1, N):
            if abs(p[i] - p[i - 1]) <= K:
                count += 1
            else:
                break

        if count == N-1:
            candidate.append(list(p))

    for c in candidate:
        count = 0
        for i in range(N):
            if c[i] != numbers[i]:
                count += 1
        if count < min_count:
            min_count = count

        print(c, count, min_count)

    if min_count > 0:
        if min_count % 2 == 0:
            return min_count//2
        else:
            return min_count//2+1
    else:
        return -1


# n, k = [10, 40, 30, 20], 20
n, k = [1, 4, 2, 3, 5], 2
# n, k = [3, 7, 2, 8, 6, 4, 5, 1], 3
# n, k = [10, 40, 30, 20], 200
# n, k = [1,9,3,7,2],5
# n, k = [1,3,7,5,9],2
print(solution(n, k))

```



#### 4. 밀가루를 사간사람은?(SQL)

테이블 2개를 join해서 원하는 결과를 가져올수있는지를 묻는 문제였다.

사용자정보가있는 테이블과 사용자가 뭘 샀는지 저장해둔 테이블을 함께 조회해서 밀가루를 사간 사람을 찾아내면된다.

join보단 서브쿼리가 익숙해서 서브쿼리로 해결했다.

아마 이런식이었던거같다.

```sql
select id from carts where id in (select cart_id from cart_product where name="밀가루") order by id group by id

select distinct(id) from carts left join cart_product on carts.id = cart_product.cart_id where name = "밀가루" order by carts.id

```









### p.s.



![image-20200422075959326](https://blog.chanwookim.me/images/image-20200422075959326.png)



한문제를 못풀었고 나머지문제들이 쉬웠어서 3번을 푼사람만 통과되지 않을까 생각했는데 통과했다!

좋은 결과가 있으면 좋겠다!

